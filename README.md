# LinuxPractice

## キーワード

### カーネル

- Linuxの中枢部をなすソフトウェアのこと
- リーナス・トーバルズ率いるコミュニティが一元管理している。
- カーネルがなければLinuxではない。
- かといってカーネルだけでは機能が少なすぎて実用的ではない

### ディストリビューション

- カーネルにいろいろなソフトを組み合わせて使いやすくしたもの
- いろいろな流派があり、個性を競い合っている
- カーネルは１つ（の系列）のみあり、ディストリビューションは1000種類以上が存在しそれぞれのコミュニティが開発している。
  - Ubuntu
  - CentOSなど

### マウント

- HDDやUSBなどを繋ぐとき、Windowsなどであれば、独立した「ドライブ」として認識する
- Unixでは、「デバイスファイル」という１つのファイルとして認識する

### シェル

- LinuxのCUIを提供するアプリというかソフトというかシステムのこと
- シェルはLinuxの一部に過ぎない。
  - LinuxはOSです。
  - シェルはCUIを提供するシステムです。
    - CUIは『character user interface』のこと。
      - 文字で操作するインタフェースのこと
  - Android（Linuxベース）の場合、CUIで操作することがないのでシェルは搭載されていない。
    - つまりLinuｘはシェルがなくても動作する。シェルはあくまでCUIを提供するツールにすぎない。

『飛ぶ』という機能を実現するために『飛行機』を使うのと同じで、
『CUI』を実現するために『シェル』を使うようなイメージ。

### ターミナル

- シェルを画面に表示するアプリというか、システムのこと。
- 「端末」「コンピュータ」とも呼ばれる

### シェルとターミナル

Unixでは、色んな機能をできるだけ細かく切り分けて作り込むという設計思想がある。

- 画面を担当するソフト（ターミナル）
- コマンドを解釈するソフト（シェル）

ターミナルとごっちゃになるけど、実は異なるもの。

## cd

- change directory
- カレントディレクトリを移動する

## pwd

- print name of working directory
- カレントディレクトリを出力

## ls

- listの略称
- ディレクトリの中身をリスト表示する
- `ls /usr` : ディレクトリ指定可能
- `ls /usr -l` : -lオプションで詳細な情報を確認できる
- `ls -l -R ./Downloads` : -Rオプションで、配下の全ての情報を確認できる

```sh
# 例
$ ls -l
drwxr-xr-x+  5 yutarom  staff        160 10 12  2019 Public/
drwxr-xr-x   5 yutarom  staff        160  2 28  2020 app/
-rw-r--r--@  1 yutarom  staff  657457152 10  6  2019 archlinux-2019.10.01-x86_64.iso
drwxr-xr-x   3 yutarom  staff         96  7 26  2019 board_game/
drwxr-xr-x  11 yutarom  staff        352 12 16  2020 code/
drwxr-xr-x   2 yutarom  staff         64  4 11  2020 dotfiles/
-rw-r--r--   1 yutarom  staff         27 10 12  2019 package-lock.json
drwxr-xr-x   5 yutarom  staff        160 12 16  2020 vagrant/
```

- ディレクトリであるか
- 権限
- リンク数
- 所有者
- グループ
- サイズ
- 最終更新日
- ディレクトリ名

## man

- manualの略称
- `man ls` : lsコマンドの使い方が確認できる
- 終了時は`q`を押下
- 文書レベルで結構な量が詳しく表示される

## --helpオプション

- `ls --help` : lsコマンドのヘルプが出力される
- manに比べてシンプルな説明が出てくる
- `help ls` : こっちでも出るかも

## mkdir

- make directoryの略称
- ディレクトリを新規作成
- `mkdir test` : testという名称のディレクトリを作成する

## mv

- moveの略称
- ディレクトリやファイルの場所を移動する、名前の変更をする
- `mv test test2` : test→test2へ変更する

## rm

- removeの略称
- 指定したファイルを削除する
- `rm -f test.txt`
  - `-f`オプションは、有無を言わさず消させる。ファイル削除の前に確認されるのを省略する。

## rmdir

- remove directoryの略称
- 指定したディレクトリを削除する

## 絶対パス・相対パス

`/` はルートディレクトリを表す。

- 絶対パス
  - ルートディレクトリから辿ってパスを表現する方法
  - `/home/taro/test` `/` ルートディレクトリ
- 相対パス
  - カレントディレクトリを起点にしどのように辿っていけば特定のファイル・ディレクトリにたどり着くかを表現する方法
  - `./taro/test` `./` カレントディレクトリ
  - カレントディレクトリから近い

## cat

- concatenateの略称
- テキストファイルの中身を表示させる
- バイナリファイルの中身を見たいなら `od -t d1 /bin/pwd` とかで見れる

## cp

- copyの略称
- ファイルをコピーする
- `cp コピー元（ファイル名） コピー先（ファイル名）`

## grep

- テキストデータから、特定の文字列パターンを持つ行だけを抜き出して表示するコマンド

## echo

- echo（やまびこ）
- `echo Hello` 標準出力でHelloを表示するだけ。
- `echo Hello > output` outputというファイルを作成してその中にHelloを出力する意味。

## 出力リダイレクト

- ダイレクト（方向づけ）、リ（やり直す）　→ リダイレクト（方向づけし直す）
- 通常の出力はターミナルに表示するが、出力リダイレクトすると、ファイルに出力する
- `date > output`とかでもできる。「> ファイル名」とすると、結果をそのファイルに書き込むことができる

### 上書き

- `date >> output` 「>>」を使用する

## 入力リダイレクト

- キーボードから行うのではなく、ファイルから入力を行う
- お試し
  - bcコマンド（対話型の計算コマンド）の有無を確認
  - `echo 2+3 > input` 計算式の書かれたファイルを作成する
  - `bc < input` 計算式の書かれたファイルをbcコマンドへ渡す

## パイプ

- `|`記号のこと
- 標準出力された内容を次のコマンドへ橋渡しするために使われるテクニック
- `echo 2+3 | bc` 「2+3」という文字列をecho出力せず、bcコマンドに渡して、その計算結果をechoしている。
  - 計算式ぽくかくとこんな感じ？　`echo ((2+3) > bc)`
  - `ls -l /usr/bin` これだと最初の方が流れてしまって見にくい
  - `ls -l /usr/bin | less` 画面サイズに合わせて１ページごとに表示してくれる
    - lsの結果をlessへ渡しているイメージですわ。
- 利点
  - 正直なところ、出力リダイレクト（ファイルに出力）→入力リダイレクトでも可能。
  - 出力リダイレクトで出力したファイル（中間ファイルと呼ぶ）は、出力結果を確認できる側面もある一方で、HDDの容量を使用してしまう
  - 入力リダイレクトに渡すときも、中間ファイルを読み込むのでパイプに比べて時間がかかる短所がある。
  - なので、慣れた人は中間ファイルを使わずパイプを活用する

### | less

- 大量の出力結果などがある場合、`| less`を使ったテクニックが多用される。
- テキストデータが入力されると、画面の縦幅に応じて１ページずつ表示させる。
  - スペースキー：１ページ分進む
  - エンターキー：1行ずつ進む
  - ↑↓キーでも操作可能

### | wc

- word countの略称
- 数を見るときに使える。
- `ls -l /usr/bin | wc`
  - 「1035    9418   63021」　行数　語数　文字数
  - 行数を見ると、/usr/binのファイルの数がわかるね

## ユーザ管理

### 基礎
- マルチユーザ（設計思想） : Unixでは、複数のユーザーが１台のコンピュータを同時に使うことができる
- アカウント（英語で口座の意味）
  - ユーザ名
  - パスワード
- 1人１つのアカウントがベター。１つのアカウントを複数人で使うのはタブー。
  - 例えば、ABC3人で共有のアカウントを使用していたとする。Aが大容量のファイルを置いたとき、HDDを圧迫して他のユーザにも影響が及ぶ。
  - 1人１つであれば、管理者はファイルの所有者を調べ、個人に警告を出すことができる
  - しかし共有アカウントだと誰がやったのか、話が複雑になる。そして個人の当事者意識も薄れ無責任な態度を取るかもしれない。
  - セキュリティの問題もあるので、1人１つが無難です。

### id

- 現在ログインしているアカウントの情報を確認できる
- `$ id`だけ。
- ユーザは、ユーザIDとユーザ名を紐付けて管理している
  - ユーザ名、ユーザIDは重複することを許容しない。一意である必要がある。
  - ユーザIDは数値（コンピュータがわかりやすい）、ユーザ名は文字列（人間がわかりやすい）関係性にある。ホストとIPアドレスみたいな感じ。

```
# このとき、ユーザIDは「1000」、ユーザ名は「yutarom」となる。
# 所属グループも見れるよ。
$ id
uid=1000(yutarom) gid=20(staff)
# 以下略
uid=1000(yutarom) gid=20(staff) 
```

### 管理者（root）

- コンピュータ内で強力な権限を持つユーザのこと
- root以外を一般ユーザと呼ぶ（rootと一般ユーザは兼用することもある）
- システムの根幹に関わる操作を行う場合、rootを使用する
  - 悪意のある攻撃を防ぐ、誤操作によるトラブルを未然に防ぐため、普段からrootアカウントを使用しない

## chmod

- change modeの略称
- ファイルやディレクトリに対する操作を可能・拒否（アクセス権限）を変更する
  - r : readable（読み取り）
  - w : writable（書き込み）
  - x : executable（実行可能）
- 権限の見方
  - １桁目　: ディレクトリかどうか
  - 2~４桁目 : 所有者（ユーザ）
  - 5~7桁目 : グループ
  - 8~10桁目 : その他のユーザ（Other）

```sh
# chmod -r output で、読み取り権限を剥奪できる
$ ls -l output
-rw-r--r--  1 yutarom  staff  7  2 11 09:29 output
$ chmod -r output
$ ls -l output
--w-------  1 yutarom  staff  7  2 11 09:29 output
cat: output: Permission denied

# chmod +r output で、読み取り権限を付与できる
$ chmod +r output
$ ls -l output
-rw-r--r--  1 yutarom  staff  7  2 11 09:29 output
$ cat output
Hello!

# 所有者以外の読み取り・書き込み権限を剥奪する方法
$ chmod u+rw output
$ ls -l output
-rw-r--r--  1 yutarom  staff  7  2 11 09:29 output

$ chmod g-rw output
$ ls -l output
-rw----r--  1 yutarom  staff  7  2 11 09:29 output

$ chmod o-rw output
$ ls -l output
-rw-------  1 yutarom  staff  7  2 11 09:29 output
```

### 権限に関する疑問

- Q. 自分一人しか使わないコンピュータ、権限の管理なんて必要なの？
  - A. 変更してはならない重要なファイルがあった場合に、wの権限を自ら剥奪します。
  - 人間どんなところでミスをするか分かりません。
  - 人間はミスをするという前提に立って、あえて書き込み権限を剥奪し、機能をあえて制限して危機管理を行うのもUnixの文化の１つです。
- Q. 読み取りのパーミッションについては？自分も読めないファイルなんて必要なの？
  - A. 必要あります。コピーの際に役立ちます。
  - 例えば大量のファイルが入ったディレクトリを、USBなどにコピーしたいとします。特定のファイルが大容量なので必要ない場合に、rの権限を剥奪します。
  - 読み取れないということはコピーもできないということになりますので、必要のないファイルを除外してコピーしたい際に活用します。

## ワンライナー

- シェル上で１行のコマンドとして走る小さなプログラムのこと。
- いくつかのコマンドをパイプなどで繋いで作る
- 「山椒は小粒でもぴりりと辛い」というように、小さくても奥深いものがあり、工夫次第でかなり複雑・高度なことができる

### シェル変数

```sh
# 変数の格納
$ x=3
$ echo $x
3

# こんな使い方も
$ d=`date`
$ echo $d
2022年 2月11日 金曜日 16時45分06秒 JST
```

### forループ

```sh
$ for a in cat dog pig; do echo $a; done
cat
dog
pig
```

「do」と「done」はペアで使う

```sh
# do~doneの間が繰り返されるコマンド
for 変数名 in 値を列挙; do 繰り返すコマンド; done
```

#### forで役立つ　seq

rangeのようなもの。

```sh
$ seq 0 5
0
1
2
3
4
5

# ``で囲んだコマンドは、実行結果が文字列に置き換えられ、for文の一部になる
# for a in 1 2 3 4 5 6 7 8 9 10; do echo $a; done と同等である
for a in `seq 1 10`; do echo $a; done
1
2
3
4
5
6
7
8
9
10
```

## カレンダー問題を解く

- 2015年の不吉な日（13日の金曜日）を取得する
- [dateコマンドをMacで使う場合の注意点](https://nonoichi123.hatenablog.com/entry/mac%25e3%2581%25a7date%25e3%2582%25b3%25e3%2583%259e%25e3%2583%25b3%25e3%2583%2589%25e3%2582%2592%25e4%25bd%25bf%25e3%2581%2584%25e3%2581%2593%25e3%2581%25aa%25e3%2581%2599/)

```sh
# Macで実施
$ date -v+1d
2022年 2月12日 土曜日 17時04分07秒 JST

$ date -j -f "%Y %m/%d" "2015 11/13"
2015年 11月13日 金曜日 17時05分03秒 JST

$ for m in `seq 1 12`; do date -j -f "%Y %m/%d" "2015 $m/13"; done
2015年 1月13日 火曜日 17時06分27秒 JST
2015年 2月13日 金曜日 17時06分27秒 JST
2015年 3月13日 金曜日 17時06分27秒 JST
2015年 4月13日 月曜日 17時06分27秒 JST
2015年 5月13日 水曜日 17時06分27秒 JST
2015年 6月13日 土曜日 17時06分27秒 JST
2015年 7月13日 月曜日 17時06分27秒 JST
2015年 8月13日 木曜日 17時06分27秒 JST
2015年 9月13日 日曜日 17時06分27秒 JST
2015年 10月13日 火曜日 17時06分27秒 JST
2015年 11月13日 金曜日 17時06分27秒 JST
2015年 12月13日 日曜日 17時06分27秒 JST

# この間に`LANG=C`を実行して使用言語を英語に変更した（これしないと、以降の結果が出ない）

$ for m in `seq 1 12`; do date -j -f "%Y %m/%d" "2015 $m/13"; done | grep Fri
Fri Feb 13 17:14:05 JST 2015
Fri Mar 13 17:14:05 JST 2015
Fri Nov 13 17:14:05 JST 2015

# 年3回ということがわかった。じゃあ2015~2024年の間では何回？
$ for y in `seq 2015 2024`; do for m in `seq 1 12`; do date -j -f "%Y %m/%d" "$y $m/13"; done | grep Fri; done
Fri Feb 13 17:17:36 JST 2015
Fri Mar 13 17:17:36 JST 2015
Fri Nov 13 17:17:36 JST 2015
Fri May 13 17:17:36 JST 2016
Fri Jan 13 17:17:36 JST 2017
Fri Oct 13 17:17:37 JST 2017
Fri Apr 13 17:17:37 JST 2018
Fri Jul 13 17:17:37 JST 2018
Fri Sep 13 17:17:37 JST 2019
Fri Dec 13 17:17:37 JST 2019
Fri Mar 13 17:17:37 JST 2020
Fri Nov 13 17:17:37 JST 2020
Fri Aug 13 17:17:37 JST 2021
Fri May 13 17:17:37 JST 2022
Fri Jan 13 17:17:37 JST 2023
Fri Oct 13 17:17:37 JST 2023
Fri Sep 13 17:17:37 JST 2024
Fri Dec 13 17:17:37 JST 2024

# １つずつ数えていく必要があるので、形式をスッキリさせる
$ for y in `seq 2015 2024`; do for m in `seq 1 12`; do date -j -f "%Y %m/%d" "$y $m/13" +"%Y %a"; done | grep Fri; done
2015 Fri
2015 Fri
2015 Fri
2016 Fri
2017 Fri
2017 Fri
2018 Fri
2018 Fri
2019 Fri
2019 Fri
2020 Fri
2020 Fri
2021 Fri
2022 Fri
2023 Fri
2023 Fri
2024 Fri
2024 Fri

# uniq: 前後で同じ行が重複したら１つにまとめる
$ for y in `seq 2015 2024`; do for m in `seq 1 12`; do date -j -f "%Y %m/%d" "$y $m/13" +"%Y %a"; done | grep Fri; done | uniq -c
   3 2015 Fri
   1 2016 Fri
   2 2017 Fri
   2 2018 Fri
   2 2019 Fri
   2 2020 Fri
   1 2021 Fri
   1 2022 Fri
   2 2023 Fri
   2 2024 Fri
```

## awk

- オークと呼ぶ
- 『Aho, Weinberger, Kernighan』の略称（3人の作者の名前） [参考](https://ja.stackoverflow.com/posts/23177/revisions)
- テキストデータを加工したりするが、このコマンド自体がプログラミング言語としての機能を備えている
- 内部のスクリプトとかも見れる。Linuxのベースに組み込まれてるコマンドだから当たり前か。[Wiki](https://ja.wikipedia.org/wiki/AWK)

```sh
# 標準出力する→パイプ→awkへ渡す→awkの持つprintコマンドを実行する（シェルとは別世界）
$ echo 100 200 | awk '{print $1}'
100

$ echo 100 200 | awk '{print $1+$2}'
300

$ echo 100 200 | awk '{print $1*$2}'
20000

# 変数も使える
$ echo 100 200 | awk '{x=$1+$2; print x}'
300

# ガウス少年（1〜100の合計値を出す）
# 1~100までの結果が１行ずつawkへ渡される→変数に加算されていく

$ seq 1 100 | awk '{s=s+$1; print $1, s}'
1 1
2 3
3 6
~~~~~~~~~
98 4851
99 4950
100 5050
```

## vi

- テキストエディタ
- 詳しい派閥のことはわからん

### コマンドモード状態で『x』　→ 一文字削除
### コマンドモード状態で『ｄｄ』　→ 一行削除
### コマンドモード状態で『u』　→ １つ前の操作に戻す

## 
